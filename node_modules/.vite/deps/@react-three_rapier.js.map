{
  "version": 3,
  "sources": ["../../fast-deep-equal/index.js", "../../@react-three/rapier/dist/react-three-rapier.esm.js", "../../use-asset/dist/index.js"],
  "sourcesContent": ["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "import { ActiveEvents, ColliderDesc, EventQueue, RigidBodyDesc } from '@dimforge/rapier3d-compat';\nexport { CoefficientCombineRule, Collider as RapierCollider, RigidBody as RapierRigidBody } from '@dimforge/rapier3d-compat';\nimport { useFrame, useThree } from '@react-three/fiber';\nimport React, { useRef, useEffect, memo, useMemo, useContext, useState, createContext, useCallback, forwardRef, Fragment } from 'react';\nimport { Quaternion, Euler, Vector3, Object3D, Matrix4, BufferAttribute, MathUtils, DynamicDrawUsage } from 'three';\nimport { useAsset } from 'use-asset';\nimport { mergeVertices } from 'three-stdlib';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst _quaternion = new Quaternion();\nnew Euler();\nconst _vector3 = new Vector3();\nnew Object3D();\nconst _matrix4 = new Matrix4();\nconst _position = new Vector3();\nconst _rotation = new Quaternion();\nconst _scale = new Vector3();\n\nconst vectorArrayToVector3 = arr => {\n  const [x, y, z] = arr;\n  return new Vector3(x, y, z);\n};\nconst tupleToObject = (tuple, keys) => {\n  return keys.reduce((obj, key, i) => {\n    obj[key] = tuple[i];\n    return obj;\n  }, {});\n};\nconst rapierQuaternionToQuaternion = ({\n  x,\n  y,\n  z,\n  w\n}) => _quaternion.set(x, y, z, w);\nconst rigidBodyTypeMap = {\n  fixed: 1,\n  dynamic: 0,\n  kinematicPosition: 2,\n  kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = type => rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale) => {\n  const scaledVerts = Array.from(vertices);\n\n  for (let i = 0; i < vertices.length / 3; i++) {\n    scaledVerts[i * 3] *= scale.x;\n    scaledVerts[i * 3 + 1] *= scale.y;\n    scaledVerts[i * 3 + 2] *= scale.z;\n  }\n\n  return scaledVerts;\n};\nconst vectorToTuple = v => {\n  if (!v) return [0];\n\n  if (v instanceof Quaternion) {\n    return [v.x, v.y, v.z, v.w];\n  }\n\n  if (v instanceof Vector3 || v instanceof Euler) {\n    return [v.x, v.y, v.z];\n  }\n\n  if (Array.isArray(v)) {\n    return v;\n  }\n\n  return [v];\n};\nfunction useConst(initialValue) {\n  const ref = useRef();\n\n  if (ref.current === undefined) {\n    ref.current = {\n      value: typeof initialValue === \"function\" ? initialValue() : initialValue\n    };\n  }\n\n  return ref.current.value;\n}\n\nconst useRaf = callback => {\n  const cb = useRef(callback);\n  const raf = useRef(0);\n  const lastFrame = useRef(0);\n  useEffect(() => {\n    cb.current = callback;\n  }, [callback]);\n  useEffect(() => {\n    const loop = () => {\n      const now = performance.now();\n      const delta = now - lastFrame.current;\n      raf.current = requestAnimationFrame(loop);\n      cb.current(delta / 1000);\n      lastFrame.current = now;\n    };\n\n    raf.current = requestAnimationFrame(loop);\n    return () => cancelAnimationFrame(raf.current);\n  }, []);\n};\n\nconst UseFrameStepper = ({\n  onStep,\n  updatePriority\n}) => {\n  useFrame((_, dt) => {\n    onStep(dt);\n  }, updatePriority);\n  return null;\n};\n\nconst RafStepper = ({\n  onStep\n}) => {\n  useRaf(dt => {\n    onStep(dt);\n  });\n  return null;\n};\n\nconst FrameStepper = ({\n  onStep,\n  type,\n  updatePriority\n}) => {\n  return type === \"independent\" ? /*#__PURE__*/React.createElement(RafStepper, {\n    onStep: onStep\n  }) : /*#__PURE__*/React.createElement(UseFrameStepper, {\n    onStep: onStep,\n    updatePriority: updatePriority\n  });\n};\n\nvar FrameStepper$1 = /*#__PURE__*/memo(FrameStepper);\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nconst _excluded$2 = [\"mass\", \"linearDamping\", \"angularDamping\", \"type\", \"onCollisionEnter\", \"onCollisionExit\", \"onIntersectionEnter\", \"onIntersectionExit\", \"onContactForce\", \"children\", \"canSleep\", \"ccd\", \"gravityScale\"];\nconst scaleColliderArgs = (shape, args, scale) => {\n  const newArgs = args.slice(); // Heightfield uses a vector\n\n  if (shape === \"heightfield\") {\n    const s = newArgs[3];\n    s.x *= scale.x;\n    s.x *= scale.y;\n    s.x *= scale.z;\n    return newArgs;\n  } // Trimesh and convex scale the vertices\n\n\n  if (shape === \"trimesh\" || shape === \"convexHull\") {\n    newArgs[0] = scaleVertices(newArgs[0], scale);\n    return newArgs;\n  } // Prepfill with some extra\n\n\n  const scaleArray = [scale.x, scale.y, scale.z, scale.x, scale.x];\n  return newArgs.map((arg, index) => scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody) => {\n  const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n\n  const desc = ColliderDesc[options.shape](...scaledArgs);\n  return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\"shape\", \"args\"];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\n\nconst setColliderMassOptions = (collider, options) => {\n  if (options.density !== undefined) {\n    if (options.mass !== undefined || options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setDensity(options.density);\n    return;\n  }\n\n  if (options.mass !== undefined) {\n    if (options.massProperties !== undefined) {\n      throw new Error(massPropertiesConflictError);\n    }\n\n    collider.setMass(options.mass);\n    return;\n  }\n\n  if (options.massProperties !== undefined) {\n    collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n  }\n};\n\nconst mutableColliderOptions = {\n  sensor: (collider, value) => {\n    collider.setSensor(value);\n  },\n  collisionGroups: (collider, value) => {\n    collider.setCollisionGroups(value);\n  },\n  solverGroups: (collider, value) => {\n    collider.setSolverGroups(value);\n  },\n  friction: (collider, value) => {\n    collider.setFriction(value);\n  },\n  frictionCombineRule: (collider, value) => {\n    collider.setFrictionCombineRule(value);\n  },\n  restitution: (collider, value) => {\n    collider.setRestitution(value);\n  },\n  restitutionCombineRule: (collider, value) => {\n    collider.setRestitutionCombineRule(value);\n  },\n  // To make sure the options all mutable options are listed\n  quaternion: () => {},\n  position: () => {},\n  rotation: () => {},\n  scale: () => {}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states) => {\n  const state = states.get(collider.handle);\n\n  if (state) {\n    var _state$worldParent;\n\n    // Update collider position based on the object's position\n    const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n    const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n    state.object.updateWorldMatrix(true, false);\n\n    _matrix4.copy(state.object.matrixWorld);\n\n    if (parentInvertedWorldMatrix) {\n      _matrix4.premultiply(parentInvertedWorldMatrix);\n    }\n\n    _matrix4.decompose(_position, _rotation, _scale);\n\n    if (collider.parent()) {\n      collider.setTranslationWrtParent({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotationWrtParent(_rotation);\n    } else {\n      collider.setTranslation({\n        x: _position.x * parentWorldScale.x,\n        y: _position.y * parentWorldScale.y,\n        z: _position.z * parentWorldScale.z\n      });\n      collider.setRotation(_rotation);\n    }\n\n    mutableColliderOptionKeys.forEach(key => {\n      if (key in options) {\n        const option = options[key];\n        mutableColliderOptions[key](collider, // @ts-ignore Option does not want to fit into the function, but it will\n        option, options);\n      }\n    }); // handle mass separately, because the assignments\n    // are exclusive.\n\n    setColliderMassOptions(collider, options);\n  }\n};\nconst useUpdateColliderOptions = (getCollider, props, states) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableColliderOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const collider = getCollider();\n    setColliderOptions(collider, props, states);\n  }, [...mutablePropsAsFlatArray, getCollider]);\n};\n\nconst isChildOfMeshCollider = child => {\n  let flag = false;\n  child.traverseAncestors(a => {\n    if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n  });\n  return flag;\n};\n\nconst createColliderState = (collider, object, rigidBodyObject) => {\n  return {\n    collider,\n    worldParent: rigidBodyObject || undefined,\n    object\n  };\n};\nconst autoColliderMap = {\n  cuboid: \"cuboid\",\n  ball: \"ball\",\n  hull: \"convexHull\",\n  trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({\n  object,\n  ignoreMeshColliders: _ignoreMeshColliders = true,\n  options\n}) => {\n  const childColliderProps = [];\n  object.updateWorldMatrix(true, false);\n  const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n\n  const colliderFromChild = child => {\n    if (\"isMesh\" in child) {\n      if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n      const worldScale = child.getWorldScale(_scale);\n      const shape = autoColliderMap[options.colliders || \"cuboid\"];\n      child.updateWorldMatrix(true, false);\n\n      _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n\n      const rotationEuler = new Euler().setFromQuaternion(_rotation, \"XYZ\");\n      const {\n        geometry\n      } = child;\n      const {\n        args,\n        offset\n      } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n\n      const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n        args: args,\n        shape: shape,\n        rotation: [rotationEuler.x, rotationEuler.y, rotationEuler.z],\n        position: [_position.x + offset.x * worldScale.x, _position.y + offset.y * worldScale.y, _position.z + offset.z * worldScale.z],\n        scale: [worldScale.x, worldScale.y, worldScale.z]\n      });\n\n      childColliderProps.push(colliderProps);\n    }\n  };\n\n  if (options.includeInvisible) {\n    object.traverse(colliderFromChild);\n  } else {\n    object.traverseVisible(colliderFromChild);\n  }\n\n  return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders) => {\n  switch (colliders) {\n    case \"cuboid\":\n      {\n        geometry.computeBoundingBox();\n        const {\n          boundingBox\n        } = geometry;\n        const size = boundingBox.getSize(new Vector3());\n        return {\n          args: [size.x / 2, size.y / 2, size.z / 2],\n          offset: boundingBox.getCenter(new Vector3())\n        };\n      }\n\n    case \"ball\":\n      {\n        geometry.computeBoundingSphere();\n        const {\n          boundingSphere\n        } = geometry;\n        const radius = boundingSphere.radius;\n        return {\n          args: [radius],\n          offset: boundingSphere.center\n        };\n      }\n\n    case \"trimesh\":\n      {\n        var _clonedGeometry$index;\n\n        const clonedGeometry = geometry.index ? geometry.clone() : mergeVertices(geometry);\n        return {\n          args: [clonedGeometry.attributes.position.array, (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array],\n          offset: new Vector3()\n        };\n      }\n\n    case \"hull\":\n      {\n        const g = geometry.clone();\n        return {\n          args: [g.attributes.position.array],\n          offset: new Vector3()\n        };\n      }\n  }\n\n  return {\n    args: [],\n    offset: new Vector3()\n  };\n};\nconst getActiveCollisionEventsFromProps = props => {\n  return {\n    collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n    contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n  };\n};\nconst useColliderEvents = (getCollider, props, events,\n/**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */\nactiveEvents = {}) => {\n  const {\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  useEffect(() => {\n    const collider = getCollider();\n\n    if (collider) {\n      const {\n        collision: collisionEventsActive,\n        contactForce: contactForceEventsActive\n      } = getActiveCollisionEventsFromProps(props);\n      const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n      const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n\n      if (hasCollisionEvent && hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS | ActiveEvents.CONTACT_FORCE_EVENTS);\n      } else if (hasCollisionEvent) {\n        collider.setActiveEvents(ActiveEvents.COLLISION_EVENTS);\n      } else if (hasContactForceEvent) {\n        collider.setActiveEvents(ActiveEvents.CONTACT_FORCE_EVENTS);\n      }\n\n      events.set(collider.handle, {\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n      });\n    }\n\n    return () => {\n      if (collider) {\n        events.delete(collider.handle);\n      }\n    };\n  }, [onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce, activeEvents]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {}) => {\n  const rest = _objectWithoutProperties(props, _excluded$2);\n\n  return rest;\n};\n\nconst useMutableCallback = fn => {\n  const ref = useRef(fn);\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n  return ref;\n}; // External hooks\n\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */\n\n\nconst useRapier = () => {\n  return useContext(rapierContext);\n};\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */\n\nconst useBeforePhysicsStep = callback => {\n  const {\n    beforeStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    beforeStepCallbacks.add(ref);\n    return () => {\n      beforeStepCallbacks.delete(ref);\n    };\n  }, []);\n};\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */\n\nconst useAfterPhysicsStep = callback => {\n  const {\n    afterStepCallbacks\n  } = useRapier();\n  const ref = useMutableCallback(callback);\n  useEffect(() => {\n    afterStepCallbacks.add(ref);\n    return () => {\n      afterStepCallbacks.delete(ref);\n    };\n  }, []);\n}; // Internal hooks\n\n/**\n * @internal\n */\n\nconst useChildColliderProps = (ref, options, ignoreMeshColliders = true) => {\n  const [colliderProps, setColliderProps] = useState([]);\n  useEffect(() => {\n    const object = ref.current;\n\n    if (object && options.colliders !== false) {\n      setColliderProps(createColliderPropsFromChildren({\n        object: ref.current,\n        options,\n        ignoreMeshColliders\n      }));\n    }\n  }, [options.colliders]);\n  return colliderProps;\n};\n\nconst Debug = /*#__PURE__*/memo(() => {\n  const {\n    world\n  } = useRapier();\n  const ref = useRef(null);\n  useFrame(() => {\n    const mesh = ref.current;\n    if (!mesh) return;\n    const buffers = world.debugRender();\n    mesh.geometry.setAttribute(\"position\", new BufferAttribute(buffers.vertices, 3));\n    mesh.geometry.setAttribute(\"color\", new BufferAttribute(buffers.colors, 4));\n  });\n  return /*#__PURE__*/React.createElement(\"group\", null, /*#__PURE__*/React.createElement(\"lineSegments\", {\n    ref: ref,\n    frustumCulled: false\n  }, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: 0xffffff,\n    vertexColors: true\n  }), /*#__PURE__*/React.createElement(\"bufferGeometry\", null)));\n});\n\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */\nconst createSingletonProxy = createInstance => {\n  let instance;\n  const handler = {\n    get(target, prop) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.get(instance, prop);\n    },\n\n    set(target, prop, value) {\n      if (!instance) {\n        instance = createInstance();\n      }\n\n      return Reflect.set(instance, prop, value);\n    }\n\n  };\n  const proxy = new Proxy({}, handler);\n\n  const reset = () => {\n    instance = undefined;\n  };\n  /**\n   * Return the proxy and a reset function\n   */\n\n\n  return {\n    proxy,\n    reset\n  };\n};\n\nconst rapierContext = /*#__PURE__*/createContext(undefined);\n\nconst getCollisionPayloadFromSource = (target, other) => {\n  var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n\n  return {\n    target: {\n      rigidBody: target.rigidBody.object,\n      collider: target.collider.object,\n      colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n      rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n    },\n    other: {\n      rigidBody: other.rigidBody.object,\n      collider: other.collider.object,\n      colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n      rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n    },\n    rigidBody: other.rigidBody.object,\n    collider: other.collider.object,\n    colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n    rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n  };\n};\n\nconst importRapier = async () => {\n  let r = await import('@dimforge/rapier3d-compat');\n  await r.init();\n  return r;\n};\n\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */\nconst Physics = props => {\n  const {\n    colliders = \"cuboid\",\n    children,\n    timeStep = 1 / 60,\n    paused = false,\n    interpolate = true,\n    updatePriority,\n    updateLoop = \"follow\",\n    debug = false,\n    gravity = [0, -9.81, 0],\n    maxStabilizationIterations = 1,\n    maxVelocityFrictionIterations = 8,\n    maxVelocityIterations = 4,\n    predictionDistance = 0.002,\n    erp = 0.8\n  } = props;\n  const rapier = useAsset(importRapier);\n  const {\n    invalidate\n  } = useThree();\n  const rigidBodyStates = useConst(() => new Map());\n  const colliderStates = useConst(() => new Map());\n  const rigidBodyEvents = useConst(() => new Map());\n  const colliderEvents = useConst(() => new Map());\n  const eventQueue = useConst(() => new EventQueue(false));\n  const beforeStepCallbacks = useConst(() => new Set());\n  const afterStepCallbacks = useConst(() => new Set());\n  /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */\n\n  const {\n    proxy: worldProxy,\n    reset: resetWorldProxy\n  } = useConst(() => createSingletonProxy(() => new rapier.World(vectorArrayToVector3(gravity))));\n  useEffect(() => {\n    return () => {\n      worldProxy.free();\n      resetWorldProxy();\n    };\n  }, []); // Update mutable props\n\n  useEffect(() => {\n    worldProxy.gravity = vectorArrayToVector3(gravity);\n    worldProxy.integrationParameters.maxStabilizationIterations = maxStabilizationIterations;\n    worldProxy.integrationParameters.maxVelocityFrictionIterations = maxVelocityFrictionIterations;\n    worldProxy.integrationParameters.maxVelocityIterations = maxVelocityIterations;\n    worldProxy.integrationParameters.predictionDistance = predictionDistance;\n    worldProxy.integrationParameters.erp = erp;\n  }, [worldProxy, ...gravity, maxStabilizationIterations, maxVelocityIterations, maxVelocityFrictionIterations, predictionDistance, erp]);\n  const getSourceFromColliderHandle = useCallback(handle => {\n    var _collider$parent;\n\n    const collider = worldProxy.getCollider(handle);\n    const colEvents = colliderEvents.get(handle);\n    const colliderState = colliderStates.get(handle);\n    const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n    const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n    const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n    const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n    const source = {\n      collider: {\n        object: collider,\n        events: colEvents,\n        state: colliderState\n      },\n      rigidBody: {\n        object: rigidBody,\n        events: rbEvents,\n        state: rigidBodyState\n      }\n    };\n    return source;\n  }, []);\n  const [steppingState] = useState({\n    previousState: {},\n    accumulator: 0\n  });\n  const step = useCallback(dt => {\n    const world = worldProxy;\n    /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */\n\n    const timeStepVariable = timeStep === \"vary\";\n    /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */\n\n    const clampedDelta = MathUtils.clamp(dt, 0, 0.5);\n\n    const stepWorld = delta => {\n      // Trigger beforeStep callbacks\n      beforeStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n      world.timestep = delta;\n      world.step(eventQueue); // Trigger afterStep callbacks\n\n      afterStepCallbacks.forEach(callback => {\n        callback.current(world);\n      });\n    };\n\n    if (timeStepVariable) {\n      stepWorld(clampedDelta);\n    } else {\n      // don't step time forwards if paused\n      // Increase accumulator\n      steppingState.accumulator += clampedDelta;\n\n      while (steppingState.accumulator >= timeStep) {\n        // Set up previous state\n        // needed for accurate interpolations if the world steps more than once\n        if (interpolate) {\n          steppingState.previousState = {};\n          world.forEachRigidBody(body => {\n            steppingState.previousState[body.handle] = {\n              position: body.translation(),\n              rotation: body.rotation()\n            };\n          });\n        }\n\n        stepWorld(timeStep);\n        steppingState.accumulator -= timeStep;\n      }\n    }\n\n    const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep; // Update meshes\n\n    rigidBodyStates.forEach((state, handle) => {\n      const rigidBody = world.getRigidBody(handle);\n      const events = rigidBodyEvents.get(handle);\n\n      if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n        if (rigidBody.isSleeping() && !state.isSleeping) {\n          var _events$onSleep;\n\n          events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n        }\n\n        if (!rigidBody.isSleeping() && state.isSleeping) {\n          var _events$onWake;\n\n          events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n        }\n\n        state.isSleeping = rigidBody.isSleeping();\n      }\n\n      if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n        return;\n      } // New states\n\n\n      let t = rigidBody.translation();\n      let r = rigidBody.rotation();\n      let previousState = steppingState.previousState[handle];\n\n      if (previousState) {\n        // Get previous simulated world position\n        _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n\n\n        if (state.meshType == \"mesh\") {\n          state.object.position.copy(_position);\n          state.object.quaternion.copy(_rotation);\n        }\n      } // Get new position\n\n\n      _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n\n      if (state.meshType == \"instancedMesh\") {\n        state.setMatrix(_matrix4);\n      } else {\n        // Interpolate to new position\n        state.object.position.lerp(_position, interpolationAlpha);\n        state.object.quaternion.slerp(_rotation, interpolationAlpha);\n      }\n    });\n    eventQueue.drainCollisionEvents((handle1, handle2, started) => {\n      const source1 = getSourceFromColliderHandle(handle1);\n      const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n\n      if (started) {\n        world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped) => {\n          var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n\n          /* RigidBody events */\n          (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n          /* Collider events */\n\n          (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n            manifold,\n            flipped\n          }));\n          (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n            manifold,\n            flipped\n          }));\n        });\n      } else {\n        var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n\n        (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n        (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n        (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n        (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n      } // Sensor Intersections\n\n\n      if (started) {\n        if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n          var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n\n          (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n          (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n          (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n          (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n        }\n      } else {\n        var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n\n        (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n        (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n        (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n        (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n      }\n    });\n    eventQueue.drainContactForceEvents(event => {\n      var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n\n      const source1 = getSourceFromColliderHandle(event.collider1());\n      const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n\n      if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n        return;\n      }\n\n      const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n      const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n      (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n      (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n        totalForce: event.totalForce(),\n        totalForceMagnitude: event.totalForceMagnitude(),\n        maxForceDirection: event.maxForceDirection(),\n        maxForceMagnitude: event.maxForceMagnitude()\n      }));\n    });\n    world.forEachActiveRigidBody(() => {\n      invalidate();\n    });\n  }, [paused, timeStep, interpolate, worldProxy]);\n  const context = useMemo(() => ({\n    rapier,\n    world: worldProxy,\n    physicsOptions: {\n      colliders,\n      gravity\n    },\n    rigidBodyStates,\n    colliderStates,\n    rigidBodyEvents,\n    colliderEvents,\n    beforeStepCallbacks,\n    afterStepCallbacks,\n    isPaused: paused,\n    isDebug: debug,\n    step\n  }), [paused, step, debug, colliders, gravity]);\n  const stepCallback = useCallback(delta => {\n    if (!paused) {\n      step(delta);\n    }\n  }, [paused, step]);\n  return /*#__PURE__*/React.createElement(rapierContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(FrameStepper$1, {\n    onStep: stepCallback,\n    type: updateLoop,\n    updatePriority: updatePriority\n  }), debug && /*#__PURE__*/React.createElement(Debug, null), children);\n};\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Initiate an instance and return a safe getter\n */\n\nconst useImperativeInstance = (createFn, destroyFn, dependencyList) => {\n  const ref = useRef();\n  const getInstance = useCallback(() => {\n    if (!ref.current) {\n      ref.current = createFn();\n    }\n\n    return ref.current;\n  }, dependencyList);\n  useEffect(() => {\n    // Save the destroy function and instance\n    const instance = getInstance();\n\n    const destroy = () => destroyFn(instance);\n\n    return () => {\n      destroy();\n      ref.current = undefined;\n    };\n  }, [getInstance]);\n  return getInstance;\n};\n\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */\n\nconst vec3 = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Vector3(x, y, z);\n};\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */\n\nconst quat = ({\n  x,\n  y,\n  z,\n  w\n} = {\n  x: 0,\n  y: 0,\n  z: 0,\n  w: 1\n}) => {\n  return new Quaternion(x, y, z, w);\n};\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */\n\nconst euler = ({\n  x,\n  y,\n  z\n} = {\n  x: 0,\n  y: 0,\n  z: 0\n}) => {\n  return new Euler(x, y, z);\n};\n\nconst useForwardedRef = (forwardedRef, defaultValue = null) => {\n  const innerRef = useRef(defaultValue); // Update the forwarded ref when the inner ref changes\n\n  if (forwardedRef && typeof forwardedRef !== \"function\") {\n    if (!forwardedRef.current) {\n      forwardedRef.current = innerRef.current;\n    }\n\n    return forwardedRef;\n  }\n\n  return innerRef;\n};\n\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */\nconst AnyCollider = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    position,\n    rotation,\n    quaternion,\n    scale,\n    name\n  } = props;\n  const {\n    world,\n    colliderEvents,\n    colliderStates\n  } = useRapier();\n  const rigidBodyContext = useRigidBodyContext();\n  const colliderRef = useForwardedRef(forwardedRef);\n  const objectRef = useRef(null); // We spread the props out here to make sure that the ref is updated when the props change.\n\n  const immutablePropArray = immutableColliderOptions.flatMap(key => Array.isArray(props[key]) ? [...props[key]] : props[key]);\n  const getInstance = useImperativeInstance(() => {\n    const worldScale = objectRef.current.getWorldScale(vec3());\n    const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n\n    if (typeof forwardedRef == \"function\") {\n      forwardedRef(collider);\n    }\n\n    colliderRef.current = collider;\n    return collider;\n  }, collider => {\n    if (world.getCollider(collider.handle)) {\n      world.removeCollider(collider, true);\n    }\n  }, [...immutablePropArray, rigidBodyContext]);\n  useEffect(() => {\n    const collider = getInstance();\n    colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n    return () => {\n      colliderStates.delete(collider.handle);\n    };\n  }, [getInstance]);\n  const mergedProps = useMemo(() => {\n    return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n  }, [props, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options]);\n  useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n  useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale,\n    ref: objectRef,\n    name: name\n  }, children);\n}));\n\n/**\n * A cuboid collider shape\n * @category Colliders\n */\nconst CuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => {\n  return /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n    shape: \"cuboid\",\n    ref: ref\n  }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n\n/**\n * A round cuboid collider shape\n * @category Colliders\n */\nconst RoundCuboidCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCuboid\",\n  ref: ref\n})));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n\n/**\n * A ball collider shape\n * @category Colliders\n */\nconst BallCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"ball\",\n  ref: ref\n})));\nBallCollider.displayName = \"BallCollider\";\n\n/**\n * A capsule collider shape\n * @category Colliders\n */\nconst CapsuleCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"capsule\",\n  ref: ref\n})));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n\n/**\n * A heightfield collider shape\n * @category Colliders\n */\nconst HeightfieldCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"heightfield\",\n  ref: ref\n})));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n\n/**\n * A trimesh collider shape\n * @category Colliders\n */\nconst TrimeshCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"trimesh\",\n  ref: ref\n})));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n\n/**\n * A cone collider shape\n * @category Colliders\n */\nconst ConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cone\",\n  ref: ref\n})));\nConeCollider.displayName = \"ConeCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundConeCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCone\",\n  ref: ref\n})));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n\n/**\n * A cylinder collider shape\n * @category Colliders\n */\nconst CylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"cylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"CylinderCollider\";\n\n/**\n * A round cylinder collider shape\n * @category Colliders\n */\nconst RoundCylinderCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"roundCylinder\",\n  ref: ref\n})));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n\n/**\n * A convex hull collider shape\n * @category Colliders\n */\nconst ConvexHullCollider = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(AnyCollider, _extends({}, props, {\n  shape: \"convexHull\",\n  ref: ref\n})));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\n\nconst rigidBodyDescFromOptions = options => {\n  var _options$canSleep;\n\n  const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n  const desc = new RigidBodyDesc(type); // Apply immutable options\n\n  desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n  return desc;\n};\nconst createRigidBodyState = ({\n  rigidBody,\n  object,\n  setMatrix,\n  getMatrix,\n  worldScale,\n  meshType: _meshType = \"mesh\"\n}) => {\n  object.updateWorldMatrix(true, false);\n  const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n  return {\n    object,\n    rigidBody,\n    invertedWorldMatrix,\n    setMatrix: setMatrix ? setMatrix : matrix => {\n      object.matrix.copy(matrix);\n    },\n    getMatrix: getMatrix ? getMatrix : matrix => matrix.copy(object.matrix),\n    scale: worldScale || object.getWorldScale(_scale).clone(),\n    isSleeping: false,\n    meshType: _meshType\n  };\n};\nconst immutableRigidBodyOptions = [\"args\", \"colliders\", \"canSleep\"];\nconst mutableRigidBodyOptions = {\n  gravityScale: (rb, value) => {\n    rb.setGravityScale(value, true);\n  },\n  linearDamping: (rb, value) => {\n    rb.setLinearDamping(value);\n  },\n  angularDamping: (rb, value) => {\n    rb.setAngularDamping(value);\n  },\n  dominanceGroup: (rb, value) => {\n    rb.setDominanceGroup(value);\n  },\n  enabledRotations: (rb, [x, y, z]) => {\n    rb.setEnabledRotations(x, y, z, true);\n  },\n  enabledTranslations: (rb, [x, y, z]) => {\n    rb.setEnabledTranslations(x, y, z, true);\n  },\n  lockRotations: (rb, value) => {\n    rb.lockRotations(value, true);\n  },\n  lockTranslations: (rb, value) => {\n    rb.lockTranslations(value, true);\n  },\n  angularVelocity: (rb, [x, y, z]) => {\n    rb.setAngvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  linearVelocity: (rb, [x, y, z]) => {\n    rb.setLinvel({\n      x,\n      y,\n      z\n    }, true);\n  },\n  ccd: (rb, value) => {\n    rb.enableCcd(value);\n  },\n  userData: (rb, value) => {\n    rb.userData = value;\n  },\n\n  type(rb, value) {\n    rb.setBodyType(rigidBodyTypeFromString(value), true);\n  },\n\n  position: () => {},\n  rotation: () => {},\n  quaternion: () => {},\n  scale: () => {}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true) => {\n  if (!rigidBody) {\n    return;\n  }\n\n  const state = states.get(rigidBody.handle);\n\n  if (state) {\n    if (updateTranslations) {\n      state.object.updateWorldMatrix(true, false);\n\n      _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n\n      rigidBody.setTranslation(_position, false);\n      rigidBody.setRotation(_rotation, false);\n    }\n\n    mutableRigidBodyOptionKeys.forEach(key => {\n      if (key in options) {\n        mutableRigidBodyOptions[key](rigidBody, options[key]);\n      }\n    });\n  }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true) => {\n  // TODO: Improve this, split each prop into its own effect\n  const mutablePropsAsFlatArray = useMemo(() => mutableRigidBodyOptionKeys.flatMap(key => {\n    return vectorToTuple(props[key]);\n  }), [props]);\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n  }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events) => {\n  const {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  } = props;\n  const eventHandlers = {\n    onWake,\n    onSleep,\n    onCollisionEnter,\n    onCollisionExit,\n    onIntersectionEnter,\n    onIntersectionExit,\n    onContactForce\n  };\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    events.set(rigidBody.handle, eventHandlers);\n    return () => {\n      events.delete(rigidBody.handle);\n    };\n  }, [onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce]);\n};\n\nconst _excluded$1 = [\"children\", \"type\", \"position\", \"rotation\", \"scale\", \"quaternion\", \"transformState\"];\nconst RigidBodyContext = /*#__PURE__*/createContext(undefined);\nconst useRigidBodyContext = () => useContext(RigidBodyContext);\n\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */\nconst RigidBody = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    type,\n    position,\n    rotation,\n    scale,\n    quaternion,\n    transformState\n  } = props,\n        objectProps = _objectWithoutProperties(props, _excluded$1);\n\n  const objectRef = useRef(null);\n  const rigidBodyRef = useForwardedRef(forwardedRef);\n  const {\n    world,\n    rigidBodyStates,\n    physicsOptions,\n    rigidBodyEvents\n  } = useRapier();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n      children: undefined\n    });\n  }, [physicsOptions, props]);\n  const immutablePropArray = immutableRigidBodyOptions.flatMap(key => {\n    return Array.isArray(mergedOptions[key]) ? [...mergedOptions[key]] : mergedOptions[key];\n  });\n  const childColliderProps = useChildColliderProps(objectRef, mergedOptions); // Provide a way to eagerly create rigidbody\n\n  const getRigidBody = useImperativeInstance(() => {\n    const desc = rigidBodyDescFromOptions(mergedOptions);\n    const rigidBody = world.createRigidBody(desc);\n\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(rigidBody);\n    }\n\n    rigidBodyRef.current = rigidBody;\n    return rigidBody;\n  }, rigidBody => {\n    if (world.getRigidBody(rigidBody.handle)) {\n      world.removeRigidBody(rigidBody);\n    }\n  }, immutablePropArray); // Only provide a object state after the ref has been set\n\n  useEffect(() => {\n    const rigidBody = getRigidBody();\n    const state = createRigidBodyState({\n      rigidBody,\n      object: objectRef.current\n    });\n    rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n    return () => {\n      rigidBodyStates.delete(rigidBody.handle);\n    };\n  }, [getRigidBody]);\n  useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n  useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n  const contextValue = useMemo(() => {\n    return {\n      ref: objectRef,\n      getRigidBody: getRigidBody,\n      options: mergedOptions\n    };\n  }, [getRigidBody]);\n  return /*#__PURE__*/React.createElement(RigidBodyContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, objectProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */\nconst MeshCollider = /*#__PURE__*/memo(props => {\n  const {\n    children,\n    type\n  } = props;\n  const {\n    physicsOptions\n  } = useRapier();\n  const object = useRef(null);\n  const {\n    options\n  } = useRigidBodyContext();\n  const mergedOptions = useMemo(() => {\n    return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n      children: undefined,\n      colliders: type\n    });\n  }, [physicsOptions, options]);\n  const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n  return /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: object,\n    userData: {\n      r3RapierType: \"MeshCollider\"\n    }\n  }, children, childColliderProps.map((colliderProps, index) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: index\n  }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\n\nconst _excluded = [\"children\", \"instances\", \"colliderNodes\", \"position\", \"rotation\", \"quaternion\", \"scale\"];\nconst InstancedRigidBodies = /*#__PURE__*/memo( /*#__PURE__*/forwardRef((props, forwardedRef) => {\n  const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n  const objectRef = useRef(null);\n  const instanceWrapperRef = useRef(null);\n\n  const {\n    // instanced props\n    children,\n    instances,\n    colliderNodes = [],\n    // wrapper object props\n    position,\n    rotation,\n    quaternion,\n    scale\n  } = props,\n        rigidBodyProps = _objectWithoutProperties(props, _excluded);\n\n  const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n    children: undefined\n  }));\n\n  const getInstancedMesh = () => {\n    const firstChild = instanceWrapperRef.current.children[0];\n\n    if (firstChild && \"isInstancedMesh\" in firstChild) {\n      return firstChild;\n    }\n\n    return undefined;\n  };\n\n  useEffect(() => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      instancedMesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    } else {\n      console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n    }\n  }, []); // Update the RigidBodyStates whenever the instances change\n\n  const applyInstancedState = (state, index) => {\n    const instancedMesh = getInstancedMesh();\n\n    if (instancedMesh) {\n      return _objectSpread2(_objectSpread2({}, state), {}, {\n        getMatrix: matrix => {\n          instancedMesh.getMatrixAt(index, matrix);\n          return matrix;\n        },\n        setMatrix: matrix => {\n          instancedMesh.setMatrixAt(index, matrix);\n          instancedMesh.instanceMatrix.needsUpdate = true;\n        },\n        meshType: \"instancedMesh\"\n      });\n    }\n\n    return state;\n  };\n\n  return /*#__PURE__*/React.createElement(\"object3D\", _extends({\n    ref: objectRef\n  }, rigidBodyProps, {\n    position: position,\n    rotation: rotation,\n    quaternion: quaternion,\n    scale: scale\n  }), /*#__PURE__*/React.createElement(\"object3D\", {\n    ref: instanceWrapperRef\n  }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index) => /*#__PURE__*/React.createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n    ref: body => rigidBodiesRef.current[index] = body,\n    transformState: state => applyInstancedState(state, index)\n  }), /*#__PURE__*/React.createElement(React.Fragment, null, colliderNodes.map((node, index) => /*#__PURE__*/React.createElement(Fragment, {\n    key: index\n  }, node)), childColliderProps.map((colliderProps, colliderIndex) => /*#__PURE__*/React.createElement(AnyCollider, _extends({\n    key: colliderIndex\n  }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n\n/**\n * @internal\n */\n\nconst useImpulseJoint = (body1, body2, params) => {\n  const {\n    world\n  } = useRapier();\n  const jointRef = useRef();\n  useImperativeInstance(() => {\n    if (body1.current && body2.current) {\n      const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n      jointRef.current = newJoint;\n      return newJoint;\n    }\n  }, joint => {\n    if (joint) {\n      jointRef.current = undefined;\n\n      if (world.getImpulseJoint(joint.handle)) {\n        world.removeImpulseJoint(joint, true);\n      }\n    }\n  }, []);\n  return jointRef;\n};\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */\n\nconst useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.fixed(vectorArrayToVector3(body1Anchor), tupleToObject(body1LocalFrame, [\"x\", \"y\", \"z\", \"w\"]), vectorArrayToVector3(body2Anchor), tupleToObject(body2LocalFrame, [\"x\", \"y\", \"z\", \"w\"])));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor]) => {\n  const {\n    rapier\n  } = useRapier();\n  return useImpulseJoint(body1, body2, rapier.JointData.spherical(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.revolute(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */\n\nconst usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits]) => {\n  const {\n    rapier\n  } = useRapier();\n  const params = rapier.JointData.prismatic(vectorArrayToVector3(body1Anchor), vectorArrayToVector3(body2Anchor), vectorArrayToVector3(axis));\n\n  if (limits) {\n    params.limitsEnabled = true;\n    params.limits = limits;\n  }\n\n  return useImpulseJoint(body1, body2, params);\n};\n\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */\nconst interactionGroups = (memberships, filters) => (bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 0b1111111111111111);\n\nconst bitmask = groups => [groups].flat().reduce((acc, layer) => acc | 1 << layer, 0);\n\nexport { AnyCollider, BallCollider, CapsuleCollider, ConeCollider, ConvexHullCollider, CuboidCollider, CylinderCollider, HeightfieldCollider, InstancedRigidBodies, MeshCollider, Physics, RigidBody, RoundConeCollider, RoundCuboidCollider, RoundCylinderCollider, TrimeshCollider, euler, interactionGroups, quat, useAfterPhysicsStep, useBeforePhysicsStep, useFixedJoint, useImpulseJoint, usePrismaticJoint, useRapier, useRevoluteJoint, useSphericalJoint, vec3 };\n", "import deepEqual from 'fast-deep-equal';\n\nconst globalCache = [];\n\nfunction handleAsset(fn, cache, args, lifespan = 0, preload = false) {\n  for (const entry of cache) {\n    // Find a match\n    if (deepEqual(args, entry.args)) {\n      // If we're pre-loading and the element is present, just return\n      if (preload) return; // If an error occurred, throw\n\n      if (entry.error) throw entry.error; // If a response was successful, return\n\n      if (entry.response) return entry.response; // If the promise is still unresolved, throw\n\n      throw entry.promise;\n    }\n  } // The request is new or has changed.\n\n\n  const entry = {\n    args,\n    promise: // Make the promise request.\n    fn(...args) // Response can't be undefined or else the loop above wouldn't be able to return it\n    // This is for promises that do not return results (delays for instance)\n    .then(response => entry.response = response != null ? response : true).catch(e => entry.error = e != null ? e : 'unknown error').then(() => {\n      if (lifespan > 0) {\n        setTimeout(() => {\n          const index = cache.indexOf(entry);\n          if (index !== -1) cache.splice(index, 1);\n        }, lifespan);\n      }\n    })\n  };\n  cache.push(entry);\n  if (!preload) throw entry.promise;\n}\n\nfunction clear(cache, ...args) {\n  if (args === undefined || args.length === 0) cache.splice(0, cache.length);else {\n    const entry = cache.find(entry => deepEqual(args, entry.args));\n\n    if (entry) {\n      const index = cache.indexOf(entry);\n      if (index !== -1) cache.splice(index, 1);\n    }\n  }\n}\n\nfunction createAsset(fn, lifespan = 0) {\n  const cache = [];\n  return {\n    /**\n     * @throws Suspense Promise if asset is not yet ready\n     * @throws Error if the promise rejected for some reason\n     */\n    read: (...args) => handleAsset(fn, cache, args, lifespan),\n    preload: (...args) => void handleAsset(fn, cache, args, lifespan, true),\n    clear: (...args) => clear(cache, ...args),\n    peek: (...args) => {\n      var _cache$find;\n\n      return (_cache$find = cache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _cache$find.response;\n    }\n  };\n}\n\nfunction useAsset(fn, ...args) {\n  return handleAsset(fn, globalCache, args, useAsset.lifespan);\n}\n\nuseAsset.lifespan = 0;\n\nuseAsset.clear = (...args) => clear(globalCache, ...args);\n\nuseAsset.preload = (fn, ...args) => void handleAsset(fn, globalCache, args, useAsset.lifespan, true);\n\nuseAsset.peek = (...args) => {\n  var _globalCache$find;\n\n  return (_globalCache$find = globalCache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _globalCache$find.response;\n};\n\nexport { createAsset, useAsset };\n"],
  "mappings": "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",
  "names": ["entry", "deepEqual", "deepEqual", "React", "index"]
}
